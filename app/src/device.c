/**
 * Generated by anjay_codegen.py on 2022-10-26 20:11:37
 *
 * LwM2M Object: Device
 * ID: 3, URN: urn:oma:lwm2m:oma:3:1.1, Mandatory, Single
 *
 * This LwM2M Object provides a range of device related information which
 * can be queried by the LwM2M Server, and a device reboot and factory
 * reset function.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_memory.h>
#include "device.h"


/**
 * Manufacturer: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Human readable manufacturer name
 */
#define RID_MANUFACTURER 0

/**
 * Model Number: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * A model identifier (manufacturer specified string)
 */
#define RID_MODEL_NUMBER 1

/**
 * Serial Number: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Serial Number
 */
#define RID_SERIAL_NUMBER 2

/**
 * Firmware Version: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Current firmware version of the Device.The Firmware Management
 * function could rely on this resource.
 */
#define RID_FIRMWARE_VERSION 3

/**
 * Reboot: E, Single, Mandatory
 * type: N/A, range: N/A, unit: N/A
 * Reboot the LwM2M Device to restore the Device from unexpected firmware
 * failure.
 */
#define RID_REBOOT 4

/**
 * Factory Reset: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Perform factory reset of the LwM2M Device to make the LwM2M Device to
 * go through initial deployment sequence where provisioning and
 * bootstrap sequence is performed. This requires client ensuring post
 * factory reset to have minimal information to allow it to carry out one
 * of the bootstrap methods specified in section 5.2.3.  When this
 * Resource is executed, "De-register" operation MAY be sent to the LwM2M
 * Server(s) before factory reset of the LwM2M Device.
 */
#define RID_FACTORY_RESET 5

/**
 * Available Power Sources: R, Multiple, Optional
 * type: integer, range: 0..7, unit: N/A
 * 0: DC power 1: Internal Battery 2: External Battery 3: Fuel Cell 4:
 * Power over Ethernet 5: USB 6: AC (Mains) power 7: Solar The same
 * Resource Instance ID MUST be used to associate a given Power Source
 * (Resource ID:6) with its Present Voltage (Resource ID:7) and its
 * Present Current (Resource ID:8)
 */
#define RID_AVAILABLE_POWER_SOURCES 6

/**
 * Power Source Voltage: R, Multiple, Optional
 * type: integer, range: N/A, unit: N/A
 * Present voltage for each Available Power Sources Resource Instance.
 * The unit used for this resource is in mV.
 */
#define RID_POWER_SOURCE_VOLTAGE 7

/**
 * Power Source Current: R, Multiple, Optional
 * type: integer, range: N/A, unit: N/A
 * Present current for each Available Power Source. The unit used for
 * this resource is in mA.
 */
#define RID_POWER_SOURCE_CURRENT 8

/**
 * Battery Level: R, Single, Optional
 * type: integer, range: 0..100, unit: %
 * Contains the current battery level as a percentage (with a range from
 * 0 to 100). This value is only valid for the Device internal Battery if
 * present (one Available Power Sources Resource Instance is 1).
 */
#define RID_BATTERY_LEVEL 9

/**
 * Memory Free: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Estimated current available amount of storage space which can store
 * data and software in the LwM2M Device (expressed in kilobytes).
 */
#define RID_MEMORY_FREE 10

/**
 * Error Code: R, Multiple, Mandatory
 * type: integer, range: 0..8, unit: N/A
 * 0=No error 1=Low battery power 2=External power supply off 3=GPS
 * module failure 4=Low received signal strength 5=Out of memory 6=SMS
 * failure 7=IP connectivity failure 8=Peripheral malfunction  When the
 * single Device Object Instance is initiated, there is only one error
 * code Resource Instance whose value is equal to 0 that means no error.
 * When the first error happens, the LwM2M Client changes error code
 * Resource Instance to any non-zero value to indicate the error type.
 * When any other error happens, a new error code Resource Instance is
 * created. When an error associated with a Resource Instance is no
 * longer present, that Resource Instance is deleted. When the single
 * existing error is no longer present, the LwM2M Client returns to the
 * original no error state where Instance 0 has value 0. This error code
 * Resource MAY be observed by the LwM2M Server. How to deal with LwM2M
 * Clientâ€™s error report depends on the policy of the LwM2M Server.
 */
#define RID_ERROR_CODE 11

/**
 * Reset Error Code: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Delete all error code Resource Instances and create only one zero-
 * value error code that implies no error, then re-evaluate all error
 * conditions and update and create Resources Instances to capture all
 * current error conditions.
 */
#define RID_RESET_ERROR_CODE 12

/**
 * Current Time: RW, Single, Optional
 * type: time, range: N/A, unit: N/A
 * Current UNIX time of the LwM2M Client. The LwM2M Client should be
 * responsible to increase this time value as every second elapses. The
 * LwM2M Server is able to write this Resource to make the LwM2M Client
 * synchronized with the LwM2M Server.
 */
#define RID_CURRENT_TIME 13

/**
 * UTC Offset: RW, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Indicates the UTC offset currently in effect for this LwM2M Device.
 * UTC+X [ISO 8601].
 */
#define RID_UTC_OFFSET 14

/**
 * Timezone: RW, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Indicates in which time zone the LwM2M Device is located, in IANA
 * Timezone (TZ) database format.
 */
#define RID_TIMEZONE 15

/**
 * Supported Binding and Modes: R, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * Indicates which bindings and modes are supported in the LwM2M Client.
 * The possible values are those listed in the LwM2M Core Specification.
 */
#define RID_SUPPORTED_BINDING_AND_MODES 16

/**
 * Device Type: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Type of the device (manufacturer specified string: e.g. smart meters /
 * dev Class / ...)
 */
#define RID_DEVICE_TYPE 17

/**
 * Hardware Version: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Current hardware version of the device
 */
#define RID_HARDWARE_VERSION 18

/**
 * Software Version: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * Current software version of the device (manufacturer specified
 * string). On elaborated LwM2M device, SW could be split in 2 parts: a
 * firmware one and a higher level software on top. Both pieces of
 * Software are together managed by LwM2M Firmware Update Object (Object
 * ID 5)
 */
#define RID_SOFTWARE_VERSION 19

/**
 * Battery Status: R, Single, Optional
 * type: integer, range: 0..6, unit: N/A
 * This value is only valid for the Device Internal Battery if present
 * (one Available Power Sources Resource Instance value is 1). Battery
 * Status  Meaning Description 0       Normal  The battery is operating
 * normally and not on power. 1       Charging        The battery is
 * currently charging. 2       Charge Complete The battery is fully
 * charged and still on power. 3       Damaged The battery has some
 * problem. 4       Low Battery     The battery is low on charge. 5
 * Not Installed   The battery is not installed. 6       Unknown The
 * battery information is not available.
 */
#define RID_BATTERY_STATUS 20

/**
 * Memory Total: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * Total amount of storage space which can store data and software in the
 * LwM2M Device (expressed in kilobytes).
 */
#define RID_MEMORY_TOTAL 21

/**
 * ExtDevInfo: R, Multiple, Optional
 * type: objlnk, range: N/A, unit: N/A
 * Reference to external "Device" object instance containing information.
 * For example, such an external device can be a Host Device, which is a
 * device into which the Device containing the LwM2M client is embedded.
 * This Resource may be used to retrieve information about the Host
 * Device.
 */
#define RID_EXTDEVINFO 22

typedef struct device_object_struct {
    const anjay_dm_object_def_t *def;

    // TODO: object state
} device_object_t;

static inline device_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, device_object_t, def);
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;
    (void) iid;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    // TODO: instance reset
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_MANUFACTURER,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MODEL_NUMBER,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SERIAL_NUMBER,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_FIRMWARE_VERSION,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_REBOOT,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_FACTORY_RESET,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_AVAILABLE_POWER_SOURCES,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_POWER_SOURCE_VOLTAGE,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_POWER_SOURCE_CURRENT,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_BATTERY_LEVEL,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MEMORY_FREE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_ERROR_CODE,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_RESET_ERROR_CODE,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_CURRENT_TIME,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_UTC_OFFSET,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_TIMEZONE,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SUPPORTED_BINDING_AND_MODES,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_DEVICE_TYPE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_HARDWARE_VERSION,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SOFTWARE_VERSION,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_BATTERY_STATUS,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MEMORY_TOTAL,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_EXTDEVINFO,
                      ANJAY_DM_RES_RM, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;
    (void) iid;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_MANUFACTURER:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, MANUFACTURER); // TODO

    case RID_MODEL_NUMBER:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, "1.1"); // TODO.

    case RID_SERIAL_NUMBER:
        assert(riid == ANJAY_ID_INVALID);
        char mac[24] = {0};
        return anjay_ret_string(ctx, mac); // TODO

    case RID_FIRMWARE_VERSION:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, "1.0"); // TODO

    case RID_AVAILABLE_POWER_SOURCES:
        // TODO: extract Resource Instance
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_POWER_SOURCE_VOLTAGE:
        // TODO: extract Resource Instance
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_POWER_SOURCE_CURRENT:
        // TODO: extract Resource Instance
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_BATTERY_LEVEL:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_MEMORY_FREE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_ERROR_CODE:
        // TODO: extract Resource Instance
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_CURRENT_TIME:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i64(ctx, 0); // TODO

    case RID_UTC_OFFSET:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_TIMEZONE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_SUPPORTED_BINDING_AND_MODES:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_DEVICE_TYPE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_HARDWARE_VERSION:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_SOFTWARE_VERSION:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_BATTERY_STATUS:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_MEMORY_TOTAL:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_EXTDEVINFO:
        // TODO: extract Resource Instance
        return anjay_ret_objlnk(ctx, 0, 0); // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx) {
    (void) anjay;
    (void) iid;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_CURRENT_TIME: {
        assert(riid == ANJAY_ID_INVALID);
        int64_t value; // TODO
        return anjay_get_i64(ctx, &value); // TODO
    }

    case RID_UTC_OFFSET: {
        assert(riid == ANJAY_ID_INVALID);
        char value[256]; // TODO
        return anjay_get_string(ctx, value, sizeof(value)); // TODO
    }

    case RID_TIMEZONE: {
        assert(riid == ANJAY_ID_INVALID);
        char value[256]; // TODO
        return anjay_get_string(ctx, value, sizeof(value)); // TODO
    }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) anjay;
    (void) iid;
    (void) arg_ctx;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_REBOOT:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

    case RID_FACTORY_RESET:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

    case RID_RESET_ERROR_CODE:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int list_resource_instances(anjay_t *anjay,
                                   const anjay_dm_object_def_t *const *obj_ptr,
                                   anjay_iid_t iid,
                                   anjay_rid_t rid,
                                   anjay_dm_list_ctx_t *ctx) {
    (void) anjay;
    (void) iid;

    device_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_AVAILABLE_POWER_SOURCES:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

    case RID_POWER_SOURCE_VOLTAGE:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

    case RID_POWER_SOURCE_CURRENT:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

    case RID_ERROR_CODE:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

    case RID_EXTDEVINFO:
        // anjay_dm_emit(ctx, ...); // TODO
        return 0;

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 3,
    .version = "1.1",
    .handlers = {
        .list_instances = anjay_dm_list_instances_SINGLE,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_write = resource_write,
        .resource_execute = resource_execute,
        .list_resource_instances = list_resource_instances,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};

const anjay_dm_object_def_t **device_object_create(void) {
    device_object_t *obj = (device_object_t *) avs_calloc(1, sizeof(device_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void device_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        device_object_t *obj = get_obj(def);

        // TODO: object cleanup

        avs_free(obj);
    }
}
